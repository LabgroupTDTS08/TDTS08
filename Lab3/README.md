#Laboration 3
## Alghorithm to decrease the complexity
We traced instruction 500000 to 500030 in go.ss for 3 players and table size 8.
To the decrease the complexity but still not increase the cykles with more than 5 % we took the easy alghorithm and took down every parameter and took it down as much that we still was in the  5% ratio and then went to the next parameter , and then went down more and did the same for all parameters. Some paremeters did effect more,almost all the parameters intill the floatpoint and
the integer multiplication did affect the cycles significant. So the program go.ss does not use any floating points at all and just very few integer multiplications. Also you can discouse how the later parameters can change alot because of the parameter we changed before, like the rru that went up from the default and also went upp 100 % which is a big increase. The algorithm is meaby not the best but it takes down the or have the same size as the default accept from the rru. 
## How the complexity affect the pipeline
We had 9 different parameters tha we could change -fetch:speed (allowed range: 1-4), decode:width (allowed range: 1-16), issue:width (allowed range: 1-8) ,-commit:width (allowed range: 1-8), -ruu:size (allowed range: 1-32), -res:ialu (allowed range: 1-4), -res:imult (allowed range: 1-4), -res:fpalu (allowed range: 1-2), -res:fpmult (allowed range: 1-2).
In our algorithm we decided to take down the fetch-speed to 1 the decode width to 4, the issue width 4, commit width to 3, ruu size increase to 32 , res ialu to 3, res imult to 1, res fpalu to 1, res fmult to 1.
The fetchspeed affects the pipeline so that the pipeline can only fetch one intruction at a time, decode with is how many instructions that can be decoded  at the same time, the issue width is a parameter linked to ruu_issue and affect how many registers that are used in some stages, commit width affects the commit stage of the pipeline and how many it can do in one cycle, ruu size is connected with issue width and affecting the amount of register used in the pipeline, the integer alu does effect in how many integer alu operations we can do in parallell, the integer multiplication affect how many integer multiplication we can do in parallell, and the two last does the same as the two before but with floatpoints.
So to sum it up is that we took down the commit width with 1, increase the ruu size with 16 , decrease the integer alu with 1 and decrease the floatpoint alu with 3. This affected the program that it took some cykles less then the default and we could not do as many commits in parallell and that we could not do as many integers alus and floating point intructions in parallell.
To analyse our algorithm is that is not problaly the best when the ruu went up as much as it did, but then register does not cost as much as the other things that we decreased.
