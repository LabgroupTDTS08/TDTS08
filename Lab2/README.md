#Laboration 2
  1. The operand LB is a operand that is loading a byte from mamory to a register. So first it (IF) fetch the intruction and then (DA) decode it to a opcode for LB, then (CO) calculate the effective adresses for the memory and the register, then (FO) fetch the byte from the memory and (EX) put the byte in the register. The last stage (WB) does not happend here because no result is needed to be stored.
  2. See apendix. 
  3. The operand ADD first (IF) fetch the intruction and (DA) decode the op-code and the adressing type, then (CO) calculate the effective adresses depending on which adress type, then (FO) fetch the values that should be added to the ALU-register, (EX) executs the addition in the ALU and then (WB) stores the result to the main memory.
  4. For the program run with branch predictor "taken" the program gets 16314464 total number of branches executed and 8730602 total number of branches committed, which means it took avery second prediction right. For branch prediction "bimod" the program gets 10631235 total number of branches executed and 8730602 total number of branches committed, which means that almost 85 % of the prediction is right. For the branch prediction "2lev" 11358589 total number of branches executed and 8730602 total number of branches committed, which is about 80% right. For branch prediction "combo" the program gets 10586746 # total number of branches executed and 8730602 total number of branches committed, which is better then "bimod". The branch predicter "perfect" gets 100% right predictions.
  5. Why the branch predictors are leveled as they are is because first taken just assume that the branch is always taken and is pretty logic that every second time it is right. Bimod have a little bit information about what have happend before and can use that to predict what is gonna happend in the future, if two ways in a row has bean taken it is more commen that the third is taken and if only one in e row has happend it is pretty commen that the same way is taken the next time. 2lev is a little bit the same as bimod but is more advanced, it has a little bit more information about whats has happend before and create common patterns and use the patterns to predict future branches, why this is not better in this case depends on the program, sometimes a simpler branch predicter is more effective it depends on the program. But if you combine bimod and 2lev then you use the both of the advantages and get a better prediction. The branch predictor perfect is simulated to always take the right branch.
