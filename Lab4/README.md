#Laboration 4
In lab 4 we have analysed a basic block in the benchmark program go.ss and optimised it according to vliw designed but also taken in consideration what material is needed for the code to run with the vliw design. The basic block index is 1023, its start adress is 0x00409750, its end adress is 0x004097b0 and it have 12 instructions in it. The basic block begins by loading 2 values that then gets left shifted and then gets added to a different register before the branch instruction came (see appendix for source code). Within the code we found 11 RAW dependencies within it that had to be taken care of for the vliw design scheme to run. The first ones was between the load and shift instructions (row 50, 68 and row 58, 70) because the same registers are being used. After that there are dependencies between the load, add and load instructions that follows (row 78, 80, 88 and row 90, 98, a0). Lastly the branch instruction (row a8) is dependent on the load instruction in row 60. All these dependencies are documented under the graph_file in appendix with the structur that the adress to the right is dependent of the result of the adress to the left. Because of this the left adress have to be run before the right adress of the row can.

##Optimeizing the basic block according to the vliw design scheme.
We created two vliw design schemes of the basic block by the names vliw1 and vliw2. These were made to run with high parallelism without breaking the dependencies and was optimiesed to have as low cost-performence ratio as possible. The cost-preformence was calculated by taking the cost of architecture that was needed to run the vliw design scheme for the basic block times the number of clock cycles that it took to run the block. The architecture cost was calculated by taking a set price for all the components that was used. In our code the add and shift instructions was done by a ALU and the load (lw) instructions used a BAU. The lui instructions did not use any specific component and was placed in an available slot in the adress row.

The vliw1 had a cost-preformence ratio of 760, was done in 5 cycles and hade a total hardware cost of 152. It was done with 2 ALUs, 1 MUL, 1 FPU and 1 BAU (for more info se appendix). In our block we had a lot of dependencies with load instructions and beacuse of that one of the most efficient way to make it faster was to add more BAU:s to our architecture. However since the cost of every BAU was so much high in comperison with the other components we decieded to not use it in our design. Instead we made the design with only one BAU and started with the first load instruction in the basic block and coupled it with the two lui instruction that was placed in the MUL and FPU slot. After that we continued by systematicly use the load instruction that was next in the dependens graph and in the end we got a design of 5 instruction row and with only one row where no parallelism was used. Beacuse of the high level of parallelism we achieved the result of the design was fairly good. The complete result can be seen under result vliw_file1 result in the appendix.

For the vliw2 design we tried to use one more BAU in our design in order to make it preform faster. However we know that if it did not preform at 3 clock cycles or less it would not be worth the extra BAU because of its high cost. However even after adding an extra ALU component to we could not get it down to less then 4 clock cycles because of the many load dependencies that exicted within the basic block. This made the cost-preformance for the vliw2 to be 1016 which is much higher for only preforming at one clock cycle faster.

Out of these two vliw designs vliw1 is much better. One thing to note thought is that none of the code in our basic block needed to use the MUL and FPU component and thus these could be seen as redudnat since the design could be done to preform the same without it, especially FPU since it has the secound highest cost of the components. However because this is only one basic block out of thousends within go.ss they could be needed in other basic blocks and thus it is good to have atleast one of every component within the architecure.


