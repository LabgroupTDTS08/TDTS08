#Laboration 4
In lab 4 we have analysed a basic block in the benchmark program go.ss and optimised it according to vliw designed but also taken in consideration what material is needed for the code to run with the vliw design. The basic block index is 1023, its start adress is 0x00409750, its end adress is 0x004097b0 and it have 12 instructions in it. The basic block begins by loading 2 values that then gets left shifted and then gets added to a different register before the branch instruction came (see appendix for source code). Within the code we found 11 RAW dependencies within it that had to be taken care of for the vliw design scheme to run. The first ones was between the load and shift instructions (row 50, 68 and row 58, 70) because the same registers are being used. After that there are dependencies between the load, add and load instructions that follows (row 78, 80, 88 and row 90, 98, a0). Lastly the branch instruction (row a8) is dependent on the load instruction in row 60. All these dependencies are documented under the graph_file in appendix with the structur that the adress to the right is dependent of the result of the adress to the left. Because of this the left adress have to be run before the right adress of the row can.

##Optimeizing the basic block according to the vliw desgin scheme.
We created two vliw desgin schemes of the basic block by the names vliw1 and vliw2. These were made to run with high parallelism without breaking the dependencies and was optimiesed to have as low cost-performence ratio as possible. The cost-preformence was calculated by taking the cost of architecture that was needed to run the vliw design scheme for the basic block times the number of clock cycles that it took to run the block. The architecture cost was calculated by taking a set price for all the components that was used. In our code the add and shift instructions was done by a ALU and the load (lw) instructions used a BAU to execut. The        
##Apendix
